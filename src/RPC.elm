module RPC exposing (..)

import Dict
import Http
import Json.Decode as D
import Json.Decode.Pipeline exposing (..)
import Json.Encode as E
import Lamdera exposing (SessionId)
import Lamdera.Json as Json
import Lamdera.Wire3 as Wire3
import LamderaRPC exposing (..)
import Task exposing (Task)
import Types exposing (..)


testEndpoint : SessionId -> BackendModel -> Headers -> String -> ( Result Http.Error Int, BackendModel, Cmd msg )
testEndpoint sessionId model headers appName =
    let
        response =
            Ok 321
    in
    ( response, model, Cmd.none )


testEndpointJson : SessionId -> BackendModel -> Headers -> E.Value -> ( Result Http.Error E.Value, BackendModel, Cmd msg )
testEndpointJson sessionId model headers appName =
    let
        response =
            Ok (Json.int 123)
    in
    ( response, model, Cmd.none )


testEndpointJsonFailure : SessionId -> BackendModel -> HttpRequest -> ( RPCResult, BackendModel, Cmd msg )
testEndpointJsonFailure sessionId model appName =
    ( ResultRaw 401
        "Custom failure"
        [ ( "custom-header", "custom-header-value" )
        , ( "content-type", "application/json" )
        ]
        (BodyString "{ 'custom': 'this is a HTTP error'}")
    , model
    , Cmd.none
    )


testEndpointString : SessionId -> BackendModel -> Headers -> String -> ( Result Http.Error String, BackendModel, Cmd msg )
testEndpointString sessionId model headers requestBody =
    let
        response =
            Ok <| "this is a raw string response for request body: " ++ requestBody ++ "\n with headers: " ++ headersToString headers
    in
    ( response, model, Cmd.none )


headersToString : Headers -> String
headersToString =
    Dict.toList >> List.map (\( k, v ) -> k ++ ": " ++ v) >> String.join "\n"



-- Things that should be auto-generated later


requestTestEndpoint : String -> (Result Http.Error Int -> msg) -> Cmd msg
requestTestEndpoint value msg =
    requestTestEndpointTask value |> Task.attempt msg


requestTestEndpointTask : String -> Task Http.Error Int
requestTestEndpointTask value =
    LamderaRPC.asTask Wire3.encodeString Wire3.decodeInt value "testEndpoint"


requestTestEndpointJson : E.Value -> (Result Http.Error E.Value -> msg) -> Cmd msg
requestTestEndpointJson value msg =
    requestTestEndpointJsonTask value |> Task.attempt msg


requestTestEndpointJsonFailure : E.Value -> (Result Http.Error E.Value -> msg) -> Cmd msg
requestTestEndpointJsonFailure value msg =
    requestTestEndpointJsonTaskFailure value |> Task.attempt msg


requestTestEndpointJsonTask : E.Value -> Task Http.Error E.Value
requestTestEndpointJsonTask value =
    LamderaRPC.asTaskJson value "testEndpointJson"


requestTestEndpointJsonTaskFailure : E.Value -> Task Http.Error E.Value
requestTestEndpointJsonTaskFailure value =
    LamderaRPC.asTaskJson value "testEndpointJsonFailure"


requestTestEndpointString : String -> (Result Http.Error String -> msg) -> Cmd msg
requestTestEndpointString value msg =
    requestTestEndpointStringTask value |> Task.attempt msg


requestTestEndpointStringTask : String -> Task Http.Error String
requestTestEndpointStringTask value =
    LamderaRPC.asTaskString value "testEndpointString"


{-| Single point for RPC request handling

  - Matches endpoint
  - Decodes arg
  - Runs update function
  - Encodes response
  - Passes back bytes with requestId

Note: async from node side, the requestId matches requests to responses

-}
lamdera_handleEndpoints : Json.Value -> HttpRequest -> BackendModel -> ( LamderaRPC.RPCResult, BackendModel, Cmd msg )
lamdera_handleEndpoints reqRaw req model =
    case req.endpoint of
        -- @TODO this needs to be autogenerated per rpc function
        "testEndpoint" ->
            LamderaRPC.handleEndpointBytes testEndpoint Wire3.decodeString Wire3.encodeInt req model

        "testEndpointJson" ->
            LamderaRPC.handleEndpointJson testEndpointJson req model

        "testEndpointJsonFailure" ->
            LamderaRPC.handleEndpoint testEndpointJsonFailure req model

        "testEndpointString" ->
            LamderaRPC.handleEndpointString testEndpointString req model

        "reverse" ->
            LamderaRPC.handleEndpointBytes reverse Wire3.decodeInt Wire3.encodeInt req model

        _ ->
            ( LamderaRPC.ResultRaw 400 "Bad request" [] <| LamderaRPC.BodyString <| "Unknown endpoint " ++ req.endpoint, model, Cmd.none )



-- Martin test


reverse : SessionId -> BackendModel -> Headers -> Int -> ( Result Http.Error Int, BackendModel, Cmd msg )
reverse sessionId model headers input =
    let
        response =
            Ok 123
    in
    ( response
    , model
    , Cmd.none
    )



-- Things that should be auto-generated later


requestReverse : Int -> Task Http.Error Int
requestReverse value =
    LamderaRPC.asTask Wire3.encodeInt Wire3.decodeInt value "reverse"


requestReverseCmd : Int -> (Result Http.Error Int -> msg) -> Cmd msg
requestReverseCmd value msg =
    requestReverse value |> Task.attempt msg